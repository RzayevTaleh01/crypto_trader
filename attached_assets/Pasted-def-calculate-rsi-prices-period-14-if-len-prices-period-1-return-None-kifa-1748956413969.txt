def calculate_rsi(prices, period=14):
    if len(prices) < period + 1:
        return None  # kifayÉ™t qÉ™dÉ™r mÉ™lumat yoxdursa
    delta = np.diff(prices)
    gain = np.where(delta > 0, delta, 0)
    loss = np.where(delta < 0, -delta, 0)
    avg_gain = np.mean(gain[-period:])
    avg_loss = np.mean(loss[-period:])
    if avg_loss == 0:
        return 100
    rs = avg_gain / avg_loss
    return 100 - (100 / (1 + rs))

def get_lot_size_info(symbol):
    info = client.get_symbol_info(symbol)
    for f in info['filters']:
        if f['filterType'] == 'LOT_SIZE':
            return f
    return None

def adjust_quantity(symbol, quantity):
    lot_size = get_lot_size_info(symbol)
    if not lot_size:
        return quantity  # qayda yoxdursa, dÃ¼z qaytar
    
    step_size = float(lot_size['stepSize'])
    min_qty = float(lot_size['minQty'])
    max_qty = float(lot_size['maxQty'])
    
    if quantity < min_qty:
        return 0  # minimumdan kiÃ§ikdirsÉ™ É™mÉ™liyyat etmÉ™
    
    # Step Ã¶lÃ§Ã¼sÃ¼nÉ™ uyÄŸun olaraq miqdarÄ± yuvarla
    precision = int(round(-np.log10(step_size), 0))
    adjusted_qty = (quantity // step_size) * step_size
    adjusted_qty = round(adjusted_qty, precision)
    
    if adjusted_qty > max_qty:
        adjusted_qty = max_qty
    
    return adjusted_qty

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Trading botuna xoÅŸ gÉ™ldiniz! /startbot ilÉ™ baÅŸla, /stopbot ilÉ™ dayandÄ±r.")

async def startbot(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global bot_running, current_balance, holdings
    if bot_running:
        await update.message.reply_text("Bot artÄ±q iÅŸlÉ™yir!")
        return
    bot_running = True
    current_balance = START_BALANCE
    holdings = {}
    await update.message.reply_text(f"Bot iÅŸÉ™ baÅŸladÄ±. MÉ™qsÉ™d: {TARGET_BALANCE} USDT.")
    asyncio.create_task(trade_loop(update))

async def stopbot(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global bot_running
    if not bot_running:
        await update.message.reply_text("Bot iÅŸlÉ™mir.")
        return
    bot_running = False
    await update.message.reply_text("Bot dayandÄ±rÄ±ldÄ±.")

async def trade_loop(update: Update):
    global bot_running, current_balance, holdings
    while bot_running:
        try:
            symbols_info = client.get_exchange_info()
            usdt_symbols = [s['symbol'] for s in symbols_info['symbols'] if s['quoteAsset'] == BASE_ASSET and s['status'] == 'TRADING']
            oversold = []
            for symbol in usdt_symbols:
                try:
                    klines = client.get_klines(symbol=symbol, interval=Client.KLINE_INTERVAL_1MINUTE, limit=20)
                    close_prices = [float(k[4]) for k in klines]
                    rsi = calculate_rsi(close_prices)
                    if rsi is not None and rsi < 30:
                        oversold.append((symbol, rsi, close_prices[-1]))
                except Exception:
                    continue

            if oversold:
                best_pair = sorted(oversold, key=lambda x: x[1])[0]
                symbol, rsi, price = best_pair
                if current_balance > 10 * 0.001:
                    quantity = (current_balance / price) * 0.99
                    quantity = adjust_quantity(symbol, quantity)
                    if quantity == 0:
                        await update.message.reply_text(f"{symbol} Ã¼Ã§Ã¼n minimum lot size tÉ™lÉ™bi tÉ™min olunmur.")
                    else:
                        try:
                            order = client.create_order(
                                symbol=symbol,
                                side=SIDE_BUY,
                                type=ORDER_TYPE_MARKET,
                                quantity=quantity
                            )
                            holdings[symbol] = (quantity, price)
                            current_balance = 0
                            await update.message.reply_text(f"ğŸ“ˆ {symbol} alÄ±ndÄ±!\nRSI: {rsi:.2f}\nMiqdar: {quantity}\nQiymÉ™t: {price}")
                        except BinanceAPIException as e:
                            await update.message.reply_text(f"Binance alÄ±ÅŸ xÉ™tasÄ±: {e}")

            for symbol in list(holdings.keys()):
                quantity, buy_price = holdings[symbol]
                klines = client.get_klines(symbol=symbol, interval=Client.KLINE_INTERVAL_1MINUTE, limit=20)
                close_prices = [float(k[4]) for k in klines]
                rsi = calculate_rsi(close_prices)
                if rsi > 70:
                    try:
                        sell_qty = adjust_quantity(symbol, quantity)
                        if sell_qty == 0:
                            await update.message.reply_text(f"{symbol} satÄ±ÅŸ Ã¼Ã§Ã¼n minimum lot size tÉ™lÉ™bi tÉ™min olunmur.")
                        else:
                            order = client.create_order(
                                symbol=symbol,
                                side=SIDE_SELL,
                                type=ORDER_TYPE_MARKET,
                                quantity=sell_qty
                            )
                            sell_price = close_prices[-1]
                            profit = (sell_price - buy_price) * sell_qty
                            current_balance += sell_price * sell_qty
                            del holdings[symbol]
                            await update.message.reply_text(f"âœ… {symbol} satÄ±ldÄ±!\nRSI: {rsi:.2f}\nQiymÉ™t: {sell_price}\nQazanc: {profit:.2f} USDT")
                    except BinanceAPIException as e:
                        await update.message.reply_text(f"Binance satÄ±ÅŸ xÉ™tasÄ±: {e}")

            if current_balance >= TARGET_BALANCE:
                bot_running = False
                await update.message.reply_text(f"ğŸ‰ MÉ™qsÉ™dÉ™ Ã§atÄ±ldÄ±! Cari balans: {current_balance:.2f} USDT. Bot dayandÄ±rÄ±lÄ±r.")
            await asyncio.sleep(60)

        except BinanceAPIException as e:
            await update.message.reply_text(f"Binance API xÉ™tasÄ±: {e}")
            await asyncio.sleep(10)
        except Exception as e:
            await update.message.reply_text(f"Ãœmumi xÉ™ta: {e}\n{traceback.format_exc()}")
            await asyncio.sleep(10)
